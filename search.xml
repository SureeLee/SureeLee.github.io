<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[冯.诺依曼体系结构？ 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 操作系统四个特性？ 并发 共享 虚拟 异步 进程有哪几种状态？转换图？ 运行态：该进程正在执行。就绪态：进程已经做好了准备，得到处理机就可以开始运行阻塞态（等待态）：进程在某些事情发生前不能执行，等待阻塞进程的事件完成，即使处理机空闲，该进程也不能运行。新建态：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中，通常是进程控制块已经创建但是还没有加载到内存中的进程。退出态：操作系统从可执行进程组中释放出的进程，或由于自身或某种原因停止运行。进程状态转换图 进程和线程的区别？ 进程是系统进行资源分配和调度的一个独立单位，是程序执行的一个实例，具有动态、并发、独立、异步的特性线程是进程的一个实体,是CPU调度和分派的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),可以与其他线程共享进程中的全部资源。总而言之： 一个程序至少有一个进程,一个进程至少有一个线程。 一个进程崩溃不影响其他进程，一个线程崩溃整个进程就崩溃。 进程在创建，切换时开销大于线程，但比线程更安全。 进程间通信 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 进程调度算法 FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化 时间片轮转调度算法(可抢占的)：每个进程被分配一个时间段，允许该进程在该时间段中运行，若超过时间，则被下一个进程抢占。 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。 线程同步 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 用户态和内核态 当程序运行在3级特权级上时，就可以称之为运行在用户态当程序运行在级特权级上时，就可以称之为运行在内核态运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，程序大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。用户态切换到内核态的3种方式： 系统调用 异常 外围设备中断 死锁的必要条件和处理方式 多个进程中，每个进程持有某种资源同时又等待其他进程的资源，在未改变这种状态之前就产生了死锁。死锁产生的四个必要条件： 互斥 一个资源一次只能被一个进程所使用 占有且等待 等待其他资源时继续占有现有资源 非抢占 不能抢占进程已有的资源 循环等待 进程之间形成一种循环资源等待关系死锁的处理方式： 预防死锁 破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量 避免死锁 在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法 检测死锁 允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 解除死锁 与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大 内存连续分配算法 内存分区：固定分区、动态分区、虚拟内存分页、虚拟内存分段、段页式 首次适应(FirstFit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 虚拟内存 如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 分页存储管理和分段存储管理 分页把程序的地址空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。分段分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。区别页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定 页面置换算法 最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 第二次机会置换算法：在先进先出算法的基础上，堆页面设置R位，如果为0就立刻置换，如果为1就清0并放入尾端。 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 最近最少使用页面置换算法LRU：置换最长时间未使用的页面，理论可实现，但代价很高 工作集页面置换算法：基本思路是找出一个不在工作集中的页面并置换它。定义一个工作集：在过去t秒内被访问的页面的集合。扫描所有页面，若R==1，说明在这个时钟滴答被访问了，它应该是工作集的一部分，把当前时间写入页表项的“上次使用时间“。若R==0，且生存时间（当前时间-上次使用时间）&gt;t,置换它，如果&lt; t,记住最小时间 工作集时钟页面置换算法：最初，该表是空的当装入第一个页面时，把它加到该表中。随着更多的页面的加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R(访问)位和M位(修改位，图中由每个表项上与时钟页面置换算法一样，每次缺页中断时，首先检查指针指向的页面。如果R为被置位1，该页面在当前工作集中，不该被淘汰。然后把该页面R置为0，指针指向下一个页面，重复该算法。当指针指向的页面R=0时，同样是比较生存时间与t。若生存时间较大，并且页面是干净的，就淘汰该页面，并把新页面放在其中。如果该页面被修改过，不能立即申请页框，为了避免写磁盘操作引起的进程切换，指针继续向前走，找到一个旧的并干净的页面。存在一种可能，所有的页面因为磁盘I/O在某个时钟周期被调度。为了降低磁盘阻塞，所以需要设置一个值n，目的是限制最大只允许写回n个页面。一旦到达该限制，不允许调度新的写操作。如果指针经过一圈并返回起始点，存在两种情况至少调度了一次写操作对于这种情况，指针仅仅是不停地移动，寻找一个干净页面。既然已经调度了一个或多个写操作，最终一定会有一个某个写操作完成，并且它的页面会被标记为干净。置换遇到的第一个干净页面，这个页面不一定是第一个被调度写操作的页面。因为磁盘驱动程序可能把写操作重排序。没有调度过写操作对于这种情况，所有页面都在工作集中。简单的方法是随便选择一个干净页面淘汰，所以在上一步的扫描过程中，需要记录所有干净页面的位置。如果不存在干净页面，那么就把当前页面淘汰。 DMA（直接内存存取） DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。要把外设的数据读入内存或把内存的数据传送到外设，一般都要通过CPU控制完成，如CPU程序查询或中断方式。利用中断进行数据传送，可以大大提高CPU的利用率。但是采用中断传送有它的缺点，对于一个高速I/O设备，以及批量交换数据的情况，只能采用DMA方式，才能解决效率和速度问题。DMA在外设与内存间直接进行数据交换，而不通过CPU，这样数据传送的速度就取决于存储器和外设的工作速度。 外存分配方式 连续分配优点：1.简便。适用于一次性写入操作。2.支持顺序存取和随机存取，顺序存取速度快。3.所需的磁盘寻道次数和寻道时间最少缺点：1.文件不能动态增长。（可能文件末尾处的空块已经分配给了别的文件）2.不利于文件的插入和删除。3.外部碎片问题。（反复增删文件后，很难找到空间大小足够的连续块，需要进行紧缩。）4.在创建文件时需声明文件大小。 链式分配优点：1.提高磁盘的空间利用率，不存在外部碎片问题。2.有利于文件的插入和删除。3.有利于文件的动态扩充’缺点：1.存取速度慢，一般只适用于信息的顺序存取，不适于随机存取。2.查找某一块必须从头到尾沿着指针进行。3.可靠性问题，如指针出错。4.更多的寻道次数和寻道时间。5.链接指针占一定的空间，将多个块组成簇，按簇进行分配而不是按块进行分配。 索引分配优点：1.保持了链接结构的优点，又解决了其缺点：按快分配可以消除外部碎片。按大小可改变的分区分配可以提高局部性。索引分配支持顺序访问文件和直接访问文件，是普遍采用的一种方式。2.满足了文件动态增长，插入删除的要求。（只要有空闲块）3.能充分利用外存空间。缺点：1.较多的寻道次数和寻道空间。2.索引表本身带来了系统开销，如：内外存空间、存取时间。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库基本概念 数据是数据库存储的基本单位。 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。 数据库管理系统是位于用户与操作系统之间的一层数据管理软件 数据库系统特点: 1. 数据结构化 2. 数据共享性高，冗余度低，以扩充。 3. 数据独立性高 4.数据由DBMS统一管理和控制 两类数据模型：第一类是概念模型(如ER图)。第二类是逻辑模型和物理模型，其中逻辑模型包括层次模型、网状模型、关系模型、面向对象模型和对象关系模型等。 数据模型的组成要素：数据结构、数据操作和完整性约束。数据模型是数据库的核心和基础。 数据库系统的三级模式是由外模式、模式和内模式构成。其中外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，一个数据库可以有多个外模式，但一个应用程序只能使用一个外模式。模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征描述，是所有用户的公共数据视图，一个数据库只有一个模式内模式也称存储模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式，一个数据库只有一个内模式。 数据库在三级模式之间提供二两层映像：外模式/模式映像 和 模式/内模式映像。这两层映像保证了数据具有较高的逻辑独立性和物理独立性。 DDL（data definition language）数据库定义语言（CREATE、ALTER、DROP）DML（data manipulation language）数据操纵语言（SELECT、UPDATE、INSERT、DELETE）DCL（Data Control Language）数据库控制语言（grant、deny、revoke） 关系代数 关系代数有交、并、差、笛卡儿积、选择、投影、连接、除等。投影后去掉重复行连接是从两个关系的笛卡儿积中选取属性满足一定条件的元组。等值连接：连接中选取条件为相等自然连接：在等值连接的基础上去掉重复属性列外连接：自然连接会去掉不相等的元组，外连接会把舍弃的元组保存在结果关系中，同时在其他属性上填NULL左外连接：保留左边要舍弃的元组右外连接：保留右边要舍弃的元组 数据库安全 用户标识与鉴别：最外层的安全保护措施，常用的方法有用户标识和口令 存取控制：主要为用户权限定义和用户权限检查，这两种组成了DBMS安全子系统。有两类方法： 自主存取控制（Grant、Revoke），不同用户有不同权限，还可以转授权限给其他用户。 强制存取控制，数据根据敏感度分为不同密级，用户许可证级别大于或等于数据密级才可以读取，用户许可证级别等于数据密级才可以写。 视图机制：为不同用户提供不同视图，可以把数据隐藏起来 审计：审计的功能把用户对数据库的所有操作自动记录下来放在审计日志。 数据加密：两种方法，置换（乱序）和替换（密钥） 数据库完整性 实体完整性：主键约束，使用PRIMARY KEY定义逐渐 参照完整性：外键约束，使用 FOREIGN KEY (xx) REFERENCES Y(yy) 用户定义完整性：包括NOT NULL、UNIQUE、CHECK. 完整性约束命名子句：CONSTRAINR [PRIMARY KEY | FOREIGN KEY | CHECK] 触发器是定义在关系表中由事件触发的特殊存储过程，用户的增删改操作都可能激活相应的触发器。常用于加强数据完整性和业务逻辑。 数据库设计 分为以下六个阶段 需求分析 设计数据字典 概念结构设计 设计E-R图 逻辑结构设计 转换为关系模式 物理结构设计 存储安排 数据库实施 编写模式，装入数据 数据库运行和维护 性能检测、转储恢复等 需求分析：设计数据字典，数据字典是各类数据的描述集合，通常包括数据项、数据结构、数据流、数据存储和处理过程。 概念结构：通常由四种设计方法，即自顶向下、自底向上、逐步扩张、混合策略。常采用自顶向下的需求分析，然后自底向上的概念结构设计。E-R图在合并时可能有三种主要冲突，即属性冲突、命名冲突、结构冲突。 逻辑结构：一个实体型转换为一个关系模式 物理结构：常用存取方法设计，索引存取方法、聚簇索引方法、HASH存取方法 数据库恢复 数据恢复的技术：数据转储和日志文件恢复策略：1. 正向扫描日志文件，找出故障发生完成的事务加入redo队列和未完成的事务加入undo队列。然后正向扫描日志文件，对每个redo事务重新执行，反向扫描日志文件，对每个undo事务恢复之前数据。 数据库事务 事务就是一个数据库的操作序列，这些操作要么全做，要么全不做，是数据库并发控制的基本单位。 事务的四个特性(ACID)：1. 原子性Atomicity 2. 一致性Consistency 3. 隔离性Isolation 4. 持续性Durability 数据库并发 事务并发带来的问题： 丢失修改：事务2的修改导致事务1的修改丢失 不可重复读：事务1读取数据后，事务2对该数据增删改，导致事务1无法读取之前结果 读脏数据：事务1修改某数据后事务2读取，此后某些原因事务1撤销，数据恢复原来值，事务2读取的与数据库不一致 封锁： 封锁有两种基本类型：排它锁(写锁)和共享锁(读锁)。 排它锁可以读取更改数据，不允许其他事务加任何锁 共享锁可以读取数据，允许其他事物加共享锁 封锁可能带来的问题： 封锁可能带来活锁和死锁两种问题。 活锁：事务1封锁数据，事务2请求封锁，这时事务3也请求封锁，事务1解锁后系统批准了事务3的请求，这时事务4又请求封锁，这样造成了事务2的永远等待。可以采取先到先服务的方法解决。 死锁：两个事务封锁了两个数据，同时又想获取对方的数据，这时两个事务就会产生死锁。 死锁的预防通常有两种方法，即一次封锁法和顺序封锁法。 一次封锁法：一次封锁发要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 顺序封锁法：预先对数据规定一个封锁顺序，所有事务都按照这个顺序实行封锁。 可串行化调度： 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行的执行这些事务时的结果相同，称这种调度策略为可串行化调度。 冲突可串行化： 冲突操作：不同事务对同一个数据的读写操作和写写操作 一个调度在抱着个冲突操作次序不变的情况下，两个事务交换不冲突操作的次序得到另一个调度次序，如果该调度是可串行的，就称该调度是冲突可串行化的。 冲突可串行化调度是可串行化调度的充分条件 两段锁协议： 在对任何数据进行读写操作之前，首先要申请并获得对该数据的封锁 在释放一个封锁之后，事务不在申请和获得任何其他封锁 封锁的粒度 IS锁、IX锁、SIX锁 主键、超键、候选键、外键 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。候选键：是最小超键，即没有冗余元素的超键。外键：在一个表中存在的另一个表的主键称此表的外键。 什么是视图？以及视图的使用场景有哪些？ 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作。视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新，使用视图可以让我们专注与逻辑，但不提高查询效率。 drop,delete与truncate的区别 drop直接删掉表truncate删除表中数据，再插入时自增长id又从1开始delete删除表中数据，可以加where字句。drop: 1. 属于DDL 2. 不可回滚 3. 不可带where 4. 表内容和结构删除 5. 删除速度快truncate table：1. 属于DDL 2. 不可回滚 3. 不可带where 4. 表内容删除 5. 删除速度快delete from：1. 属于DML 2. 可回滚 3. 可带where 4. 表结构在，表内容要看where执行的情况 5. 删除速度慢,需要逐行删除 什么是存储过程？有哪些优缺点？ 存储过程就是封装了一系列带有逻辑意义的数据库操作。存储过程的优点：只需一次创建，任意调用存储过程比SQL语句执行的要快。 可以降低网络通信量，提高通信速率更好的安全机制存储过程的缺点：每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）业务逻辑放在数据库上，难以迭代 数据库的乐观锁和悲观锁是什么？ 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作在查询完数据的时候就把事务锁起来，直到提交事务实现方式：使用数据库中的锁机制乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定实现方式：使用version版本或者时间戳 索引是什么？有什么作用以及优缺点？ 索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构索引分类：唯一索引：唯一索引不允许两行具有相同的索引值主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个。优点: 1. 索引加快数据库的检索速度 2. 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能缺点: 1. 索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引) 2. 索引需要占物理和数据空间 范式 BCNF:所有主属性之间也不存在部份依赖，且没有任何属性完全依赖yu 数据库优化 数据库表结构的优化包括选择合适数据类型、表的范式的优化、表的垂直拆分和表的水平拆分等手段。选择合适数据类型： 1. 使用较小的数据类型解决问题 2.使用简单的数据类型(mysql处理int要比varchar容易) 3. 尽可能的使用not null 定义字段 4. 尽量避免使用text类型，非用不可时最好考虑分表；表的范式的优化：一般情况下，表的设计应该遵循三大范式。表的垂直拆分：把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段： 把不常用的字段单独放在同一个表中； 把大字段独立放入一个表中； 把经常使用的字段放在一起； 这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单。 表的水平拆分：表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种： 对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值； 针对不同的hashID将数据存入不同的表中； 系统配置的优化：操作系统配置的优化：增加TCP支持的队列数 mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances） 硬件的优化： CPU：核心数多并且主频高的 内存：增大内存 磁盘配置和选择：磁盘性能]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2018%2F07%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[OSI有哪几层？每层作用？每层协议？从下至上： 物理层作用：确保比特流可以在任意物理介质上传输协议：RJ4、IEEE802.3、CLOCK设备：中继器、集线器数据链路层作用：将源主机网络层的数据传输到目的主机的网络层，在不可靠的物理介质上实现可靠传输，只能在局域网中传输协议：PPP、HDLC、LLC、MAC设备：网桥、交换机网络层作用：负责数据包的转发、分组、交换，路由寻址，网络层可以跨局域网传输协议：IP、ICMP、ARP、RARP、IGMP、RIP、OSPF、BGP设备：路由器传输层作用：将上层数据分段并提供端到端的流量控制和差错检测，对高层屏蔽通信细节协议：TCP、UDP、连续ARQ协议、停止等待协议、滑动窗口协议会话层作用：建立、管理、终止会话协议：RPC、NFS、SQL表示层作用:负责数据压缩、恢复、加密等协议：JPEG、MPEG、ASII应用层作用：为操作系统和应用程序提供网络接口，使其可以使用网络交互协议：FTP、DNS、HTTP、WWW、SMTP、Telnet ip地址分类？ A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。255.255.255.255为受限广播地址，作用范围为本地网络0.0.0.0代指本机地址127.0.0.1网络回环地址，用户测试 硬件（MAC）地址的概念及作用 MAC地址是计算机的唯一标识，在数据链路层中，交换机通过识别MAC地址进行数据包的传输。长度为6字节48比特 ARP协议的用途及算法、在哪一层上会使用ARP ？ 用途：解决一个局域网内主机或路由器的ip地址和mac地址的映射问题算法：每个主机的ARP高速缓存中存放一张ip和mac 的映射表，并时常更新网络层上使用ARP 如何实现透明传输 透明传输概念：数据透明传输就是用户不受协议中的任何限制，可随机的传输任意比特编码的信息实现透明传输技术：1. 转义字符填充 2. 零比特填充 3. 采用特殊的信号与编码 4. 确定长度(就不需要帧定界符) 各个层使用的网络设备及作用 物理层用到的设备是集线器和中继器数据链路层用到的设备是交换机和网桥网络层用到的设备是路由器应用层用到的设备是网关中继器的主要功能是对接收到的信号进行再生整形放大以扩大网络的传输距离。集线器在此基础上将所有的节点集中在以它为中心的节点中，可组成星型拓扑结构。交换机是一种基于MAC识别，能完成封装转发数据包功能的网络设备。它可以“学习”MAC地址，并把其存放在内部地址表中，当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。交换机将局域网分为多个冲突域，每个冲突域都是有独立的宽带，因此大大提高了局域网的带宽。网桥具有近具有两个端口，而交换机具有多个端口，网桥可以简单看作低配的交换机路由器用于连接多个逻辑上分开的网络，具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。网关在网络层以上实现网络互连，用于两个高层协议不同的网络互连。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。 路由表的内容 destination mask pre ads costdestination：目的地址，用来标识IP包 的目的地址或者目的网络。 mask：网络掩码，与目的地址一起标识目的主机或者路由器所在的网段的地址。 pre：标识路由加入IP路由表的优先级。可能到达一个目的地有多条路由，但是优先级的存在让他们先选择优先级高的路由进行利用。 cost：路由开销，当到达一个目的地的多个路由优先级相同时，路由开销最小的将成为最优路由。 interface：输出接口，说明IP包将从该路由器哪个接口转发。 nexthop：下一跳IP地址，说明IP包所经过的下一个路由器 路由转发算法 路由器接到一个数据报（MAC帧），先从IP数据报的首部提取目的主机的IP地址D，得出目的主机所在的网络地址N。（IP数据报首部中包含源地址和目的地址） 如果N就是这个路由器直接相连的某个网络，则可以进行直接交付；否则执行3. 如果路由表中有目的地址D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则执行4. 如果路由表中有到达网络N的路由，则把数据报传送给路由表所指明的下一跳路由器；否则执行5. 如果路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行6.6.报告转发分组报错。 MTU和路径MTU 路径MTU：路径MTU是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值。或者从另外一个角度来看，就是无需进行分片处理就能穿过这条“路径”的最大传输单元的最大值。路径MTU的发现方法：这是确定两个IP主机之间路径最大传输单元的技术，其目的就是为了避免IP分片。首先源地址将数据报的DF位置位，在逐渐增大发送的数据报的大小——路径上任何需要将分组进行分片的设备都会将这种数据报丢弃并返回“数据报过大“的ICMP响应到源地址——这样源主机就”学习“到了无需分片就能通过这条路径的最大的最大传输单元。 ping的实现原理 Ping（Packet InterNet Groper）分组网间探测是ICMP的一个重要应用，用 来测试两个主机之间的连通性。Ping使用了ICMP回送请求与回送回答报文。Ping是应用层直接使用网络层ICMP的一个例子。它没有通过运输层的TCP或UDP。实现原理为向目的主机发送4个32字节长的ICMP回送请求报文，若目的主机正常工作并且响应了该ICMP回送请求报文，就将发回ICMP回送回答报文。最后可得出的统计结果为目的IP地址，发送的，收到的和丢失的分组数，及往返时间的最小值、最大值和平均值。 子网划分和子网掩码 划分子网是在本网络内部，对外仍然只有一个网络。子网划分从主机号借位变成子网号，三级地址：网络号：子网号：主机号子网掩码也是32位，由一串1和跟随的一串0组成。子网掩码中的1对应于IP地址中原来的网络号和子网号，而子网掩码中的0对应于现在的主机号。故将子网掩码和IP地址进行按位”与“运算（AND），就可得出网络地址。 ip地址分类 ip分类 DNS查询算法 DNS查询有两种方法，第一种是递归查询，主机向本地域名服务器请求，若本地域名服务器不知道，则由服务器继续向顶级域名服务器发送请求。第二种是迭代查询，当本地域名服务器像顶级服务器发送请求后，顶级服务器会告诉你应该向哪个服务器发送请求，然后由本地服务器继续请求，而不是由顶级服务器帮你发送。 TCP与UDP TCP（Transmission Control Protocol）TCP是一种面向连接的，提供可靠交付服务和全双工通信的，基于字节流的端到端的传输层通信协议。 TCP在传输数据之前必须先建立连接，数据传输结束后要释放连接。 每一条TCP连接只能有2个端点，故TCP不提供广播或多播服务。 TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。 TCP是面向字节流的。虽然应用进程和TCP的交互是一次一个数据块(大小不等），但TCP把英语程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传输的字节流的含义。UDP（User Datagram Protocol）UDP是一种无连接的，尽最大努力交付的，基于报文的端到端的传输层通信协议。 UDP，在发送数据之前不需要建立连接 UDP不保证可靠交付，主机不需要位置复杂的连接状态 UDP是面向报文的。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的的边界，即应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收端，UDP一次交付一个完整的报文。 UDP没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。 UDP支持一对一、一对多、多对一和多对多的交互通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。区别 TCP协议面向连接，UDP协议面向非连接 TCP协议传输速度慢，UDP协议传输速度快 TCP协议保证数据顺序，UDP协议不保证 TCP协议保证数据正确性，UDP协议可能丢包 TCP协议对系统资源要求多，UDP协议要求少 TCP是面向字节流的，UDP是面向报文的使用情况TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景。对应协议TCP对应协议：FTP，Telnet、SMTP、POP3、HTTP、HTTPSUDP对应协议:DNS、SNMP、TFTP MAC帧首尾部、ip首部、TCP、UDP首部 帧长度由于协议不同不固定，其中ppp帧长度64~1518字节，MTU最大传输单元46~1500字节ip首部长度20~60字节TCP首部长度20~60字节UDP首部长度8字节ip首部TCP首部UDP首部 三次握手，四次断开过程 在TCP连接建立过程中要解决以下3个问题： 要使每一方能够确知对方的存在 要允许双方协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量） 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程是客户，而被动等待连接建立的应用进程是服务器。具体过程 为什么客户端在TIME-WAIT状态必须等待2MSL的时间？ 客户端发送的最后一个确认连接中断的ACK报文段可能丢失，因而使处在 LAST-ACK状态的服务器收不到确认。服务器会超时重传FIN+ACK报文段，客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重启计时器。最好，客户端和服务器都正常进入到CLOSED状态。如果客户端在TIME-WAIT状态不等待一段时间，而是再发送完ACK报文后立即释放连接，那么就无法收到服务器重传的FIN+ACK报文段，因而也不会再发送一次确认报文。这样，服务器就无法按照正常步骤进入CLOSED状态。 防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个ACK确认报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 停止等待协议、连续ARQ协议、滑动窗口协议 ARQ协议，即自动重传请求（Automatic Repeat-reQuest），发送方发送之后会设置一个重传计时器(时间略长于数据往返时间)，如果超过这个时间没有收到确认就自动重传，ARQ包括停止等待协议和连续ARQ协议。停止等待协议：一次只发送和接受一个数据，信道利用率低连续ARQ协议（由滑动窗口协议实现）：一次发送多个数据，不需要逐个收到确认，接收方会对按序到达的最后一个分组发送确认，就代表之前的都正确接收。若发送方发送了前5个分组，而第3个分组丢失了，接收方只能对前2个发出确认。发送方而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。滑动窗口协议：滑动窗口协议在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP的滑动窗口是以字节为单位的。 拥塞控制 发送方会维持一个拥塞窗口cwnd，发送的窗口上限值=Min[rwnd,cwnd]，rwnd是接收方发送过来的允许发生窗口大小。 慢开始 发送窗口由小到大，根据传输轮次成指数增长，同时设置一个慢开始门限ssthresh，当超过这个限制时采取拥塞避免算法。 拥塞避免 每个传输轮次发送窗口增大1在慢开始和拥塞避免过程中如果发送拥塞，则将ssthresh变为拥塞窗口的一半，并将发送窗口重设为1，重新开始慢开始算法。 快重传 当接收方收到一个失序报文就立即发送前一个正确报文的重复确认，当发送方连续收到三个重复确认后，立即重传未收到确认的报文，而不等到重传计时器到期。 快恢复 如果连续收到三个重复确认，就立即将ssthresh减小一半，然后开始执行拥塞避免算法，而不是从新开始执行慢开始。 ICMP协议和IGMP协议 ICMP的全称是 Internet Control Message Protocol 。从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有： 侦测远端主机是否存在 建立及维护路由资料 重导数据传送路径 数据流量控制组播：加入同一个组的主机可以接收到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯广播：是指在IP子网内广播数据包，所有在子网内部的主机都将收到这些数据包。广播意味着网络向子网每一个主机都投递一份数据包，不论这些主机是否乐于接收该数据包。所以广播的使用范围非常小，只在本地子网内有效，通过路由器和网络设备控制广播传输。IGMP（Internet Group Management Protocol）它用来在ip主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。让连接在本地局域网上的组播路由器知道本局域网上是否有主机上的某个进程参加或退出了某个组播组。 RIP协议和OSPF协议 路由信息协议RIP是一种分布式的基于距离向量的路由选择协议属于内部网关协议。RIP协议中的“距离”也称为“跳数”，因为每经过一个路由器，跳数就加1。算法： 对每一个相邻路由器发送过来的RIP报文，进行以下步骤： 对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的”距离”字段的值加1.每个项目都有三个关键数据，即：目的网络N，距离是d，下一跳路由器是X。 对修改后的RIP报文中的每一个项目，进行如下步骤：若原来的路由表中没有目的网络N，则把该项目添加到路由表中，若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目若收到的项目中距离d小于路由表中的距离，则进行更新 若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可到达的路由器，即把距离设置为16。 返回OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 NAT协议、DHCP协议、DNS协议的作用 NAT协议：网络地址转换(NAT,Network AddressTranslation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。DHCP协议：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 常用端口号 21 FTP22 SSH23 Telnet25 SMTP53 DNS80 HTTP110 POP3443 HTTPS1080 Sockets1521 oracle3306 mysql 电路交换和分组交换 电路交换在通信前通信双方要建立一条被双方独占的物理链路，三个阶段是建立连接，交换，释放连接优点：数据传输延时小。按顺序发送，不存在失序问题。即可以传输模拟信号也可以传输数字信号。随时通信，随机性强。设备简单。缺点：建立连接时间长。不能被其他用户使用，信道利用率低。不同类型的终端难以互相通信，也难以进行差错控制。分组交换以分组为单位进行转发和交换，采用存储-转发的方式，分组会被暂存在存储器上临时存储和处理，等待后续发送。优点：不需要为通信双方事先建立连接，不存在建立连接时延，随时发送。可以任意选择合适的线路进行发送，增加可靠性。通信双方不是固定占有一条线路，而是分时分段占有，增加信道利用率。一个分组可以转发给多个目标。在存储转发中容易实现代码转换和速率匹配，这样就便于不同类型的终端之间进行通信。分组断，出错几率较低。缺点：要经历存储-转发这一过程，增加了转发时延。仅适用于数字信号。可能会出现，失序、丢失或重复分组的情况，增加了后续排序的工作。每个分组都要加上一些额外信息，增加了信息量。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
